#include <unistd.h>
#include <stdio.h>
#include <errno.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <sys/uio.h>
#include <netinet/in.h>
#include <string.h>
#include <netdb.h>
#include <time.h>
#include <jni.h>

#include "util.h"
#include "../config.h"
#include "../report_data/report.h"

/**
 * getaddrinfo
 * getnameinfo
 * gethostbyname
 */

/**
 * android 4.0.3: getaddrinfo=>android_getaddrinfo_proxy
 * android 4.1.1: getaddrinfo=>android_getaddrinfo_proxy
 * android 4.2  : getaddrinfo=>android_getaddrinfo_proxy
 * android 4.3  : getaddrinfo=>android_getaddrinfoforiface(5)
 * android 4.4  : getaddrinfo=>android_getaddrinfoforiface(6)
 * android 5.0  : getaddrinfo=>android_getaddrinfofornet
 * android 6.0  : getaddrinfo=>android_getaddrinfofornet
 * android 7.0  : getaddrinfo=>android_getaddrinfofornet
 */

// TODO: android 4.3
int xhook_android_getaddrinfoforiface(const char *hostname,
                                      const char *servname,
                                      const struct addrinfo *hints,
                                      const char *iface,
                                      struct addrinfo **res);
HOOK_INFO system_hook_info_android_getaddrinfoforiface = {{},
                                                          "libc.",
                                                          "android_getaddrinfoforiface",
                                                          xhook_android_getaddrinfoforiface,
                                                          xhook_android_getaddrinfoforiface};
int xhook_android_getaddrinfoforiface(const char *hostname,
                                      const char *servname,
                                      const struct addrinfo *hints,
                                      const char *iface,
                                      struct addrinfo **res) {
    int (*orig_android_getaddrinfoforiface)(const char *hostname,
                                            const char *servname,
                                            const struct addrinfo *hints,
                                            const char *iface,
                                            struct addrinfo **res);
    struct timeval t1;
    gettimeofday(&t1,NULL);
    struct hook_t eph = system_hook_info_android_getaddrinfoforiface.eph;
    orig_android_getaddrinfoforiface = (void*)eph.orig;
    hook_precall(&eph);
    int status = orig_android_getaddrinfoforiface(hostname, servname, hints, iface, res);
    hook_postcall(&eph);
    struct timeval t2;
    gettimeofday(&t2,NULL);

    // InetAddress.java#getAllByNameImpl
    // (1)parseNumericAddressNoThrow
    // (2)lookupHostByName
    // TODO:
    if (hints != NULL) {
        if ((hints->ai_socktype == SOCK_STREAM) && (hints->ai_flags == AI_ADDRCONFIG)) {
            LOGD("<<<<<<<<<<<<<<<<<<DNS START<<<<<<<<<<<<<<<<<<<<<<<<<");
        LOGD("hostname=%s, servname=%s, ai_family=%d, ai_socktype=%d, ai_flags=0x%X, ai_protocol=%d",
            hostname, servname, hints->ai_family, hints->ai_socktype, hints->ai_flags, hints->ai_protocol);
        LOGD("status=%d, dns_start=%ld, duration=%ldms\n", status, (t1.tv_sec + t1.tv_usec / 1000000),
            ((t2.tv_sec - t1.tv_sec) * 1000 + (t2.tv_usec - t1.tv_usec) / 1000));
        if (status != 0) {
            LOGD("error msg:%s\n", gai_strerror(status));
        }

        struct addrinfo *cur;
        struct sockaddr_in *addr;
        char ipbuf[16];
        pthread_t tidp;
        REPORT_INFO *report_info;
        report_info = (REPORT_INFO *)malloc(sizeof(REPORT_INFO));
        if (!report_info) {
            LOGE("malloc report_info failed");
            return status;
        }
        for (cur = *res; cur != NULL; cur = cur->ai_next) {
            addr = (struct sockaddr_in *)cur->ai_addr;
            inet_ntop(AF_INET, &addr->sin_addr, ipbuf, 16);
            LOGD("ip=%s, port=%d, ai_canonname=%s\n", ipbuf, addr->sin_port, cur->ai_canonname);
            strcat(report_info->address, ipbuf);
            strcat(report_info->address, ";");
        }
        LOGD("ipList=%s\n", report_info->address);
        report_info->fd = -1;
        report_info->type = 7;
        report_info->startTime = (t1.tv_sec + t1.tv_usec / 1000000);
        report_info->timeElapsed = (t2.tv_sec - t1.tv_sec) * 1000 + (t2.tv_usec - t1.tv_usec) / 1000;
        report_info->returnValue = status;
        report_info->errorNum = 0;
        strcpy(report_info->host, hostname);
        if (status != 0) {
            strcpy(report_info->desc, gai_strerror(status));
        }
        report_info->port = 0;
        int err = pthread_create(&tidp, NULL, thread_run, report_info);
        if (err != 0) {
            LOGE("can not create report thread");
            free(report_info);
        }
            LOGD(">>>>>>>>>>>>>>>>>>DNS END>>>>>>>>>>>>>>>>>>>>>>>>");
        }
    }

    return status;
}

int xhook_android_getaddrinfofornet(const char *hostname,
                                    const char *servname,
                                    const struct addrinfo *hints,
                                    unsigned netid,
                                    unsigned mark,
                                    struct addrinfo **res);
HOOK_INFO system_hook_info_android_getaddrinfofornet = {{},
                                                        "libc.",
                                                        "android_getaddrinfofornet",
                                                        xhook_android_getaddrinfofornet,
                                                        xhook_android_getaddrinfofornet};
int xhook_android_getaddrinfofornet(const char *hostname,
                                    const char *servname,
                                    const struct addrinfo *hints,
                                    unsigned netid,
                                    unsigned mark,
                                    struct addrinfo **res) {
    int (*orig_android_getaddrinfofornet)(const char *hostname,
                                          const char *servname,
                                          const struct addrinfo *hints,
                                          unsigned netid,
                                          unsigned mark,
                                          struct addrinfo **res);
    struct hook_t eph = system_hook_info_android_getaddrinfofornet.eph;
    orig_android_getaddrinfofornet = (void*)eph.orig;
    hook_precall(&eph);
    int status = orig_android_getaddrinfofornet(hostname, servname, hints, netid, mark, res);
    hook_postcall(&eph);

    LOGE(">>>>>>>>>>>>>>>>>>xhook_android_getaddrinfofornet>>>>>>>>>>>>>>>>>>>>>>>>");
    return status;
}


//int xhook_getaddrinfo(const char *, const char *, const struct addrinfo *, struct addrinfo **);
//HOOK_INFO system_hook_info_getaddrinfo = {{},
//                                          "libc.",
//                                          "getaddrinfo",
//                                          xhook_getaddrinfo,
//                                          xhook_getaddrinfo};
//int xhook_getaddrinfo(const char *hostname,
//                      const char *service,
//                      const struct addrinfo *hints,
//                      struct addrinfo **result) {
////    struct timeval t1;
////    gettimeofday(&t1,NULL);
//    int (*orig_getaddrinfo)(const char *hostname, const char *service, const struct addrinfo *hints,
//        struct addrinfo **result);
//    struct hook_t eph = system_hook_info_getaddrinfo.eph;
//    orig_getaddrinfo = (void*)eph.orig;
//    hook_precall(&eph);
//    int status = orig_getaddrinfo(hostname, service, hints, result);
//    hook_postcall(&eph);
////    struct timeval t2;
////    gettimeofday(&t2,NULL);
//
//    LOGD(">>>>>>>>>>>>>>>>>>orig_getaddrinfo>>>>>>>>>>>>>>>>>>>>>>>>");
//
//
//    // InetAddress.java#getAllByNameImpl
//    // (1)parseNumericAddressNoThrow
//    // (2)lookupHostByName
//    // TODO:
////    if (hints != null) {
////        if ((hints->ai_socktype == SOCK_STREAM) && (hints->ai_flags == AI_ADDRCONFIG)) {
////            LOGD("<<<<<<<<<<<<<<<<<<DNS START<<<<<<<<<<<<<<<<<<<<<<<<<");
//////        LOGD("hostname=%s, service=%s, ai_family=%d, ai_socktype=%d, ai_flags=0x%X, ai_protocol=%d",
//////            hostname, service, hints->ai_family, hints->ai_socktype, hints->ai_flags, hints->ai_protocol);
//////        LOGD("status=%d, dns_start=%ld, duration=%ldms\n", status, (t1.tv_sec + t1.tv_usec / 1000000),
//////            ((t2.tv_sec - t1.tv_sec) * 1000 + (t2.tv_usec - t1.tv_usec) / 1000));
//////        if (status != 0) {
//////            LOGD("error msg:%s\n", gai_strerror(status));
//////        }
//////
//////        struct addrinfo *cur;
//////        struct sockaddr_in *addr;
//////        char ipbuf[16];
//////        pthread_t tidp;
//////        REPORT_INFO *report_info;
//////        report_info = (REPORT_INFO *)malloc(sizeof(REPORT_INFO));
//////        if (!report_info) {
//////            LOGE("malloc report_info failed");
//////            return status;
//////        }
//////        for (cur = *result; cur != NULL; cur = cur->ai_next) {
//////            addr = (struct sockaddr_in *)cur->ai_addr;
//////            inet_ntop(AF_INET, &addr->sin_addr, ipbuf, 16);
//////            LOGD("ip=%s, port=%d, ai_canonname=%s\n", ipbuf, addr->sin_port, cur->ai_canonname);
//////            strcat(report_info->address, ipbuf);
//////            strcat(report_info->address, ";");
//////        }
//////        LOGD("ipList=%s\n", report_info->address);
//////        report_info->fd = -1;
//////        report_info->type = 7;
//////        report_info->startTime = (t1.tv_sec + t1.tv_usec / 1000000);
//////        report_info->timeElapsed = (t2.tv_sec - t1.tv_sec) * 1000 + (t2.tv_usec - t1.tv_usec) / 1000;
//////        report_info->returnValue = status;
//////        report_info->errorNum = 0;
//////        strcpy(report_info->host, hostname);
//////        if (status != 0) {
//////            strcpy(report_info->desc, gai_strerror(status));
//////        }
//////        report_info->port = 0;
//////        int err = pthread_create(&tidp, NULL, thread_run, report_info);
//////        if (err != 0) {
//////            LOGE("can not create report thread");
//////            free(report_info);
//////        }
////            LOGD(">>>>>>>>>>>>>>>>>>DNS END>>>>>>>>>>>>>>>>>>>>>>>>");
////        }
////    }
//    return status;
//}


struct hostent *xhook_gethostbyname(const char *name);
HOOK_INFO system_hook_info_gethostbyname = {{},
                                            "libc.",
                                            "gethostbyname",
                                            xhook_gethostbyname,
                                            xhook_gethostbyname};
struct hostent *xhook_gethostbyname(const char *name) {
    struct hostent *(*orig_gethostbyname)(const char *name);
    struct hook_t eph = system_hook_info_gethostbyname.eph;
    orig_gethostbyname = (void*)eph.orig;
    hook_precall(&eph);
    struct hostent *hostent = orig_gethostbyname(name);
    hook_postcall(&eph);

    LOGE(">>>>>>>>>>>>>>>>xhook_gethostbyname<<<<<<<<<<<<<<<<<<");
    return hostent;
}



